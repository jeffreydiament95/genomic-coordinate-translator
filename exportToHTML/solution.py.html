<html>
<head>
<title>solution.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
solution.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">argparse</span>


<span class="s0">class </span><span class="s1">Solution:</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">make_index_map(pos</span><span class="s0">, </span><span class="s1">cigar):</span>
        <span class="s2">&quot;&quot;&quot; 
        Converts chromosome starting position and CIGAR string into transcript-&gt;chromosome index map 
 
        Parameters: 
            pos (int): The starting index on the chromosome. 
            cigar (str): The CIGAR string describing the transcript. 
 
        Returns: 
            array: the transcript-&gt;chromosome index map 
            (i.e. value at position N is chromosome coordinate corresponding to transcript coordinate N 
        &quot;&quot;&quot;</span>
        <span class="s1">trans_to_chrom_map = []</span>
        <span class="s1">chrom_index = pos</span>

        <span class="s1">matches = re.findall(</span><span class="s3">r'\d+[MIDNSHPX=]'</span><span class="s0">, </span><span class="s1">cigar)</span>

        <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">matches:</span>
            <span class="s1">num = int(match[:-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">op = match[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s5"># alignment match (can be a sequence match or mismatch)</span>
            <span class="s0">if </span><span class="s1">op == </span><span class="s3">'M'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">True</span>
                <span class="s1">consumes_chrom = </span><span class="s0">True</span>

            <span class="s5"># insertion to the reference</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">'I'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">True</span>
                <span class="s1">consumes_chrom = </span><span class="s0">False</span>

            <span class="s5"># deletion from the reference</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">'D'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">False</span>
                <span class="s1">consumes_chrom = </span><span class="s0">True</span>

            <span class="s5"># skipped region from the reference</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">'N'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">False</span>
                <span class="s1">consumes_chrom = </span><span class="s0">True</span>

            <span class="s5"># soft clipping (clipped sequences present in SEQ)</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">'S'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">True</span>
                <span class="s1">consumes_chrom = </span><span class="s0">False</span>

            <span class="s5"># hard clipping (clipped sequences NOT present in SEQ)</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">'H'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">False</span>
                <span class="s1">consumes_chrom = </span><span class="s0">False</span>

            <span class="s5"># padding (silent deletion from padded reference)</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">'P'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">False</span>
                <span class="s1">consumes_chrom = </span><span class="s0">False</span>

            <span class="s5"># sequence match</span>
            <span class="s0">if </span><span class="s1">op == </span><span class="s3">'='</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">True</span>
                <span class="s1">consumes_chrom = </span><span class="s0">True</span>

            <span class="s5"># sequence mismatch</span>
            <span class="s0">if </span><span class="s1">op == </span><span class="s3">'X'</span><span class="s1">:</span>
                <span class="s1">consumes_trans = </span><span class="s0">True</span>
                <span class="s1">consumes_chrom = </span><span class="s0">True</span>

            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">num):</span>
                <span class="s0">if </span><span class="s1">consumes_trans:</span>
                    <span class="s1">trans_to_chrom_map.append(chrom_index)</span>
                <span class="s0">if </span><span class="s1">consumes_chrom:</span>
                    <span class="s1">chrom_index += </span><span class="s4">1</span>

        <span class="s0">return </span><span class="s1">trans_to_chrom_map</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">is_valid_cigar(s):</span>
        <span class="s2">&quot;&quot;&quot; 
        Checks if a string is a valid CIGAR string. 
 
        Parameters: 
            s (str): The string to be tested. 
 
        Returns: 
            bool: True if it's a CIGAR string, False if not 
        &quot;&quot;&quot;</span>
        <span class="s1">cigar_pattern = </span><span class="s3">r'^([1-9]\d*[MIDNSHPX=])+$'</span>
        <span class="s0">return </span><span class="s1">bool(re.match(cigar_pattern</span><span class="s0">, </span><span class="s1">s))</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">get_chrom(df_transcript_info</span><span class="s0">, </span><span class="s1">row):</span>
        <span class="s2">&quot;&quot;&quot; 
        Given a transcript_info DataFrame and a row of a different DataFrame, extracts the chromosome information 
        associated with the transcript of the row, if available. 
 
        Parameters: 
            df_transcript_info (pd.DataFrame): DataFrame containing transcript information, with at least the columns 
                                             &quot;trans&quot; and &quot;chrom&quot;. 
            row (pd.Series): A row of a different DataFrame that has a &quot;trans&quot; column with values matching those in 
                             the &quot;trans&quot; column of the transcript_info DataFrame. 
 
        Returns: 
            str: The chromosome information associated with the transcript of the row, if found in the df_transcript_info 
                 DataFrame. Otherwise, returns the string &quot;NA&quot;. 
        &quot;&quot;&quot;</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">chrom = df_transcript_info[</span><span class="s3">&quot;chrom&quot;</span><span class="s1">].loc[df_transcript_info[</span><span class="s3">&quot;trans&quot;</span><span class="s1">] == row[</span><span class="s3">&quot;trans&quot;</span><span class="s1">]].iloc[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s1">chrom = </span><span class="s3">&quot;NA&quot;</span>
        <span class="s0">return </span><span class="s1">chrom</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">get_chrom_index(df_transcript_info</span><span class="s0">, </span><span class="s1">row):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns the chromosomal index of the transcript given its index on the transcript. 
 
        Parameters: 
            df_transcript_info (pandas.DataFrame): A DataFrame containing transcript information, including 
                the transcript ID, chromosome name, and an index map that maps transcript indices to 
                chromosomal indices. 
            row (pandas.Series): A row of a DataFrame containing information about a single transcript, including 
                the transcript ID and its index on the transcript. 
 
        Returns: 
            int: The chromosomal index of the transcript corresponding to the input transcript index. Returns -1 
            if the input transcript index is out of range. 
        &quot;&quot;&quot;</span>

        <span class="s1">index_map = df_transcript_info[</span><span class="s3">&quot;index_map&quot;</span><span class="s1">].loc[df_transcript_info[</span><span class="s3">&quot;trans&quot;</span><span class="s1">] == row[</span><span class="s3">&quot;trans&quot;</span><span class="s1">]].iloc[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">trans_index = row[</span><span class="s3">&quot;trans_index&quot;</span><span class="s1">]</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">chrom_index = index_map[trans_index]</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s1">print(</span><span class="s3">&quot;Transcript {} index {} out of range.&quot;</span><span class="s1">.format(row[</span><span class="s3">&quot;trans&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">row[</span><span class="s3">&quot;trans_index&quot;</span><span class="s1">]))</span>
            <span class="s1">chrom_index = -</span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">chrom_index</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">solve(input_path_1</span><span class="s0">, </span><span class="s1">input_path_2</span><span class="s0">, </span><span class="s1">output_path):</span>
        <span class="s2">&quot;&quot;&quot; 
        Translates transcript coordinates to genomic coordinates 
 
        Parameters: 
            input_path_1 (str): Path to four column, tab-separated file with columns for: 
                transcript name, chromosome name, 0-based starting position on chromosome, CIGAR string indicating mapping 
            input_path_2 (st): Path to two column, tab-separated file with columns for: 
                transcript name, 0-based transcript coordinate 
            output_path(str): Path for newly created four column, tab-separated file with columns for: 
                transcript name, 0-based transcript coordinate, chromosome name, chromosome coordinate 
 
        Returns: 
            None 
        &quot;&quot;&quot;</span>

        <span class="s5"># read first input file into dataframe</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">df_transcript_info = pd.read_csv(input_path_1</span><span class="s0">, </span><span class="s1">delimiter=</span><span class="s3">&quot;</span><span class="s0">\t</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s1">header=</span><span class="s0">None,</span>
                                             <span class="s1">names=[</span><span class="s3">&quot;trans&quot;</span><span class="s0">, </span><span class="s3">&quot;chrom&quot;</span><span class="s0">, </span><span class="s3">&quot;chrom_index&quot;</span><span class="s0">, </span><span class="s3">&quot;cigar&quot;</span><span class="s1">]</span><span class="s0">,</span>
                                             <span class="s1">dtype={</span><span class="s4">0</span><span class="s1">: str</span><span class="s0">, </span><span class="s4">1</span><span class="s1">: str</span><span class="s0">, </span><span class="s4">2</span><span class="s1">: int</span><span class="s0">, </span><span class="s4">3</span><span class="s1">: str})</span>

            <span class="s1">valid_cigars = df_transcript_info[</span><span class="s3">'cigar'</span><span class="s1">].apply(Solution.is_valid_cigar)</span>
            <span class="s1">invalid_indices = valid_cigars[~valid_cigars].index</span>
            <span class="s0">if </span><span class="s1">len(invalid_indices) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid CIGAR strings found at indices: {}&quot;</span><span class="s1">.format(invalid_indices))</span>
            <span class="s1">print(</span><span class="s3">&quot;Input 1 successfully read from: {}&quot;</span><span class="s1">.format(input_path_1))</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">print(</span><span class="s3">&quot;Error reading input file 1: {}. Please fix file and re-run.&quot;</span><span class="s1">.format(input_path_1))</span>
            <span class="s1">print((str(e)))</span>
            <span class="s1">sys.exit(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># read second input file into dataframe</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">df_queries = pd.read_csv(input_path_2</span><span class="s0">, </span><span class="s1">delimiter=</span><span class="s3">&quot;</span><span class="s0">\t</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s1">header=</span><span class="s0">None,</span>
                                     <span class="s1">names=[</span><span class="s3">&quot;trans&quot;</span><span class="s0">, </span><span class="s3">&quot;trans_index&quot;</span><span class="s1">])</span>
            <span class="s1">print(</span><span class="s3">&quot;Input 2 successfully read from: {}&quot;</span><span class="s1">.format(input_path_2))</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">print(</span><span class="s3">&quot;Error reading input file 2: {}. Please fix file and re-run.&quot;</span><span class="s1">.format(input_path_2))</span>
            <span class="s1">print((str(e)))</span>
            <span class="s1">sys.exit(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># add transcript-&gt;chromosome map to transcript info dataframe</span>
        <span class="s1">df_transcript_info[</span><span class="s3">&quot;index_map&quot;</span><span class="s1">] = df_transcript_info.apply(</span>
            <span class="s0">lambda </span><span class="s1">row: Solution.make_index_map(row[</span><span class="s3">&quot;chrom_index&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">row[</span><span class="s3">&quot;cigar&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># create output dataframe and populate with transcript chromosome name and coordinates</span>
        <span class="s1">df_output = df_queries.copy()</span>
        <span class="s1">df_output[</span><span class="s3">&quot;chrom&quot;</span><span class="s1">] = df_output.apply(</span><span class="s0">lambda </span><span class="s1">row: Solution.get_chrom(df_transcript_info</span><span class="s0">, </span><span class="s1">row)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">df_output[</span><span class="s3">&quot;chrom_index&quot;</span><span class="s1">] = df_output.apply(</span><span class="s0">lambda </span><span class="s1">row: Solution.get_chrom_index(df_transcript_info</span><span class="s0">, </span><span class="s1">row)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># write to output file</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">df_output.to_csv(output_path</span><span class="s0">, </span><span class="s1">sep=</span><span class="s3">'</span><span class="s0">\t</span><span class="s3">'</span><span class="s0">, </span><span class="s1">header=</span><span class="s0">False, </span><span class="s1">index=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s3">&quot;Output file successfully written to: {}.&quot;</span><span class="s1">.format(output_path))</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">print(</span><span class="s3">&quot;Error writing to output file: {}. Please address issue and re-run.&quot;</span><span class="s1">.format(output_path))</span>
            <span class="s1">print((str(e)))</span>
            <span class="s1">sys.exit(</span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Parse arguments from command line and pass them to main(). See comments above for more details on inputs. 
 
    Returns: 
        None 
    &quot;&quot;&quot;</span>

    <span class="s5"># if run from the command line, parse input arguments</span>
    <span class="s1">parser = argparse.ArgumentParser()</span>
    <span class="s1">parser.add_argument(</span><span class="s3">'input_path_1'</span><span class="s0">, </span><span class="s1">type=str</span><span class="s0">, </span><span class="s1">help=</span><span class="s3">'Path to input file 1 (transcript information)'</span><span class="s1">)</span>
    <span class="s1">parser.add_argument(</span><span class="s3">'input_path_2'</span><span class="s0">, </span><span class="s1">type=str</span><span class="s0">, </span><span class="s1">help=</span><span class="s3">'Path to input file 2 (transcript coordinate queries)'</span><span class="s1">)</span>
    <span class="s1">parser.add_argument(</span><span class="s3">'output_path'</span><span class="s0">, </span><span class="s1">type=str</span><span class="s0">, </span><span class="s1">help=</span><span class="s3">'Path to output file (to be created)'</span><span class="s1">)</span>
    <span class="s1">args = parser.parse_args()</span>
    <span class="s1">Solution.solve(args.input_path_1</span><span class="s0">, </span><span class="s1">args.input_path_2</span><span class="s0">, </span><span class="s1">args.output_path)</span></pre>
</body>
</html>